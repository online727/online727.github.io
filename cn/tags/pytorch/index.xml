<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pytorch on 赵浩翰 - 博客</title><link>https://online727.github.io/cn/tags/pytorch/</link><description>Recent content in Pytorch on 赵浩翰 - 博客</description><generator>Hugo -- gohugo.io</generator><language>cn</language><lastBuildDate>Tue, 13 Aug 2024 22:02:00 +0800</lastBuildDate><atom:link href="https://online727.github.io/cn/tags/pytorch/index.xml" rel="self" type="application/rss+xml"/><item><title>第四章 多层感知机</title><link>https://online727.github.io/cn/posts/dltorch/ch4/</link><pubDate>Tue, 13 Aug 2024 22:02:00 +0800</pubDate><guid>https://online727.github.io/cn/posts/dltorch/ch4/</guid><description>&lt;p>&lt;strong>多层感知机&lt;/strong> 是最简单的深度网络，由多层神经元组成，每一层与它的上一层相连，从中接收输入；同时每一层也与它的下一层相连，影响当前层的神经元。本章还涉及许多基本的概念介绍，包括过拟合、欠拟合、模型选择、数值稳定性、参数初始化以及权重衰减和暂退法等正则化技术。&lt;/p>
&lt;h2 id="1-多层感知机">1. 多层感知机&lt;/h2>
&lt;h3 id="11-简介">1.1 简介&lt;/h3>
&lt;p>在第三章中涉及了线性回归和 softmax 回归，并在线性的背景下使用 Pytorch 进行了简单实现，这两个简单的回归基于第三章中介绍的 &lt;strong>仿射变换&lt;/strong>，即一个带有偏置项的线性变换，但是，在实际生活中，&lt;strong>线性&lt;/strong> 是一个非常强的假设。&lt;/p>
&lt;p>我们或许有理由说一个人的年收入与其贷款是否违约具有负向线性相关性，但对于第三章章讨论的图像分类问题，就很难认为某个像素点的强度与其类别之间的关系仍是线性的。因此，我们选择构建一个深度神经网络，通过 &lt;strong>隐藏层&lt;/strong> 的计算为我们的数据构建一种 &lt;strong>表示&lt;/strong>，这种表示可以考虑特征之间的交互作用，在表示上，我们再建立一个线性模型用于预测可能是合适的。&lt;/p>
&lt;p>通过在网络中加入一个或多个隐藏层，配合激活函数，我们便可以克服线性模型的限制，使其能处理更普遍的函数关系。最简单的方式就是将许多全连接层堆叠在一起，每一层都输出到其上面的层，直到生成最后的输出。我们可以把前 $L-1$ 层看作表示，最后一层看作线性预测器。这种架构通常称为 &lt;strong>多层感知机&lt;/strong> (multilayer perceptron)，通常缩写为 &lt;code>MLP&lt;/code>。一般多层感知机的架构如下图所示：&lt;/p>
&lt;img src="https://online727.github.io/posts/dltorch/ch4/images/MLP.png"
alt="多层感知机"
class="center"
>
&lt;div style="margin-top: rem;">&lt;/div>
&lt;p>这个多层感知机有 4 个输入，3 个输出，其隐藏层包含 5 个隐藏单元。输入层不涉及任何计算，因此，这个多层感知机中的层数为 2。由于隐藏层和输出层都是全连接的，每个输入都会影响隐藏层中的每个神经元，而隐藏层中的每个神经元又会影响输出层中的每个神经元。&lt;/p>
&lt;p>以 $\bold{X}\in\mathbb{R}^{n\times d}$ 来表示 $n$ 个样本的小批量，其中每个样本具有 $d$ 个输入特征。对于具有 $h$ 个隐藏单元的单隐藏层多层感知机，用 $\bold{H}\in\mathbb{R}^{n\times h}$ 表示隐藏层的输出，称为 &lt;strong>隐藏表示&lt;/strong> (hidden representations)，&lt;strong>隐藏层变量&lt;/strong> (hidden-layer variable) 或 &lt;strong>隐藏变量&lt;/strong> (hidden variable)。对于全连接的隐藏层和输出层，有隐藏层权重 $\bold{W}^{(1)}\in\mathbb{R}^{d\times h}$ 和隐藏层偏置 $\bold{b}^{(1)}\in\mathbb{R}^{1\times h}$ 以及输出层权重 $\bold{W}^{(2)}\in\mathbb{R}^{h\times q}$ 和输出层偏置 $\bold{b}^{(2)}\in\mathbb{R}^{1\times 1}$。由此便可以计算单隐藏层多层感知机的输出：
$$
\begin{align*}
\bold{H} &amp;amp;= \bold{XW}^{(1)} + \bold{b}^{(1)} \cr
\bold{O} &amp;amp;= \bold{HW}^{(2)} + \bold{b}^{(2)} \cr
\end{align*}
$$&lt;/p></description></item><item><title>第三章 线性神经网络</title><link>https://online727.github.io/cn/posts/dltorch/ch3/</link><pubDate>Sun, 28 Jul 2024 21:57:00 +0800</pubDate><guid>https://online727.github.io/cn/posts/dltorch/ch3/</guid><description>&lt;h2 id="1-线性回归">1. 线性回归&lt;/h2>
&lt;h3 id="11-线性回归的基本元素">1.1 线性回归的基本元素&lt;/h3>
&lt;h4 id="111-线性模型">1.1.1 线性模型&lt;/h4>
&lt;p>线性回归，假设自变量 $\bold{x}$ 和因变量 $y$ 之间为线性关系，其中可能包含噪声，但噪声是比较正常的，如噪声服从正态分布。&lt;/p>
&lt;p>给定一个样本 $\bold{x}\in\mathbb{R}^{d}$，即具有 $d$ 个特征，将所有系数记为 $\bold{w}\in\mathbb{R}^{d}$，线性回归的基本形式为：
$$
\hat{y} = \bold{w}^{T}\bold{x} + b
$$&lt;/p>
&lt;p>矩阵形式下，$\bold{X}\in\mathbb{R}^{n\times d}$ 为所有样本的特征，此时线性回归表示为：
$$
\hat{\bold{y}} = \bold{Xw} + b
$$&lt;/p>
&lt;p>给定训练数据集 $\bold{X}$ 和对应标签 $\bold{y}$，线性回归的目标就是找到一组权重向量 $\bold{w}$ 和偏置 $b$，使得所有样本的预测误差尽可能小。&lt;/p>
&lt;h4 id="112-损失函数">1.1.2 损失函数&lt;/h4>
&lt;p>损失函数，用以度量上面提到的 “预测误差”，通常选择一个非负数作为损失，且该损失越小越好。回归问题中，最常用的损失函数为 &lt;strong>平方误差&lt;/strong>，当样本 $i$ 的预测值为 $\hat{y}^{(i)}$，相应真实标签为 $y^{(i)}$ 时，平方误差定义为：
$$
l^{(i)}(\bold{w}, b) = \frac{1}{2}\left(\hat{y}^{(i)} - y^{(i)} \right)^{2}
$$&lt;/p>
&lt;p>$\frac{1}{2}$ 是为了损失函数求导时常数系数为 1,不会有本质差别。&lt;/p>
&lt;p>那么，为了度量模型在整个训练集上的表现，就需要计算在整个训练集 $n$ 个样本上的损失均值 (等价于求和)：
$$
L(\bold{w}, b) = \frac{1}{n}\sum_{i=1}^{n}l^{(i)}(\bold{w},b) = \frac{1}{n}\sum_{i=1}^{n}\frac{1}{2}\left(\bold{w}^{T}\bold{x}^{(i)} + b - y^{(i)} \right)^{2}
$$&lt;/p></description></item><item><title>第二章 预备知识</title><link>https://online727.github.io/cn/posts/dltorch/ch2/</link><pubDate>Sat, 27 Jul 2024 17:06:25 +0800</pubDate><guid>https://online727.github.io/cn/posts/dltorch/ch2/</guid><description>&lt;p>接下来一段时间，我想自学深度学习，使用的教材为 &lt;strong>动手学深度学习 (Pytorch 版)&lt;/strong>，该书有线上网址，且提供配套代码和相关 Python 包，详情可参见 &lt;a href="https://zh.d2l.ai/" target="_blank" rel="noopener">动手学深度学习&lt;/a>。&lt;/p>
&lt;p>第一章内容，介绍了深度学习的相关背景和应用场景，以及深度学习领域常见的术语和名词，有一定机器学习经验的人或许已比较熟悉，故不再赘述，我们直接从第二章开始。&lt;/p>
&lt;h2 id="1-tensor-操作和数据预处理">1. Tensor 操作和数据预处理&lt;/h2>
&lt;p>深度学习中的数据以&lt;strong>张量&lt;/strong> (tensor) 形式存储，支持 GPU 计算和 autograd 自动微分。&lt;/p>
&lt;p>张量的创建、变形、运算 (按元素 / 矩阵)、广播机制、索引、切片等均与 &lt;code>numpy.ndarray&lt;/code> 类似。&lt;/p>
&lt;div class="alert success">
&lt;span>&lt;i data-feather="check-circle">&lt;/i>&lt;/span>
&lt;span>&lt;strong>节省内存：
&lt;code>Y = X + Y&lt;/code> 不是原地操作，即：&lt;code>id(Y = X + Y) != id(Y)&lt;/code>，会分配新的内存。
使用 &lt;code>Y[:] = X + Y&lt;/code> 或 &lt;code>Y += X&lt;/code> 进行原地操作以避免不必要的内存分配。&lt;/strong>&lt;/span>
&lt;/div>
&lt;p>Tensor 可以与其他 Python 对象互相转换，如 &lt;code>tensor.numpy()&lt;/code>。大小为 1 的张量可以转化为 Python 标量，使用 &lt;code>tensor.item()&lt;/code> 或 &lt;code>float(tensor)&lt;/code> 等。&lt;/p>
&lt;p>数据需要经过预处理，如填充 &lt;code>nan&lt;/code>，标准化等，可以借用其他 Python 包处理后再转化为 tensor。&lt;/p>
&lt;h2 id="2-线性代数">2. 线性代数&lt;/h2>
&lt;ol>
&lt;li>标量，以小写字母 $x,y,z$ 等表示。&lt;/li>
&lt;li>向量，以粗体小写字母 $\bold{x,y,z}$ 表示，向量的维度 (形状) 代表元素个数 (向量长度)，可以使用 &lt;code>len(x), x.shape&lt;/code> 获取。以列向量为默认的向量方向，例如：
$$
\begin{equation*}
x = \begin{bmatrix*}
x_{1} \cr
x_{2} \cr
\vdots \cr
x_{n}
\end{bmatrix*}
\end{equation*}
$$&lt;/li>
&lt;li>矩阵，以粗体大写字母 $\bold{X,Y,Z}$ 表示，是具有两个轴的张量。&lt;/li>
&lt;li>张量 (此处指代数对象)，矩阵的拓展，一种具有更多轴的数据结构，使用特殊字体的大写字母 $X, Y, Z$ 表示。&lt;/li>
&lt;/ol>
&lt;p>张量的计算，与 &lt;code>numpy.ndarray&lt;/code> 相同，普通的加减乘除、求和、平均、向量点积、矩阵 hadamard 积、矩阵-向量积、矩阵乘法、范数等。&lt;/p></description></item></channel></rss>